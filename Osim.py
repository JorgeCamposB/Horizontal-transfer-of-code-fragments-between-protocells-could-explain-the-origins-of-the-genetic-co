from agent import Agent
import itertools
import random as RND
from random import choice as CH
from random import sample as SM
import math
import copy
from copy import deepcopy
import pylab
from pylab import *
from matplotlib.font_manager import FontProperties
import numpy as np
import matplotlib.pyplot as plt
import scipy
from scipy import stats
from scipy.spatial import distance
import pickle


# A general function to calculate the euclidean distance between the features of the aminoacids
# We can take it as a simmilarity matrix

def calculateEDistance(Data):
    SimMat = np.zeros((Data.shape[0],Data.shape[0]))
    for i in range(0,Data.shape[0]):
        for j in range(0,Data.shape[0]):
            SimMat[i][j]=distance.euclidean(Data[i,:],Data[j,:])
    maxSM=np.max(SimMat)
    for i in range(0,Data.shape[0]):
        for j in range(0,Data.shape[0]):
            SimMat[i][j]=1-(SimMat[i][j]/maxSM)
    return SimMat


# A function to calculate the distance between aminoacids using the polar requirement
# This is the way to get the matrix of polar requirement used to calculate the delta error

def calculatePolarReqDist(polarReq):
    PolarDist = np.zeros((len(polarReq),len(polarReq)))
    for i in range(0,Data.shape[0]):
        for j in range(0,len(polarReq)):
            PolarDist[i][j]=np.abs(polarReq[i]-polarReq[j])
    return PolarDist


# A function to export the polar requirement distance matrix

def exportPolarMat(PolarDist):
    np.savetxt("polarDist.csv",PolarDist,delimiter=',',fmt="%.2f")


    
# Loading the data sets necessary to run the simulation
    
Data = np.loadtxt('11Features.csv',delimiter=',')
aminoAcids = np.genfromtxt('aminoAcids.csv',delimiter=',',dtype='str')
polarReq = np.loadtxt('PolarReq.csv',delimiter=',')
polarDisd = calculatePolarReqDist(polarReq)
SimilarityMatrix = calculateEDistance(Data)
exportPolarMat(polarDisd)


# A class to implement the simulations

class Sim:
    def __init__(self, params,reloadFlag=False):
        """ Inputs of constructor:
                params -----> Full dictionary imported from Omain.py
        """
        # Initialization of parameters from the Omain.py file
        # Setting the random seed that we got from the parameters
        # Setting the transfer number to 0
        self.params = params
        RND.seed(params['randomSeed'])
        self.transferNumber = 0
            
        # Set up graph control
        self.graphXAxis = []
        self.graphYAxis = []
        self.graphYAxis2 = []
        self.graphYAxis3 = []
        self.graphYAxis4 = []
        self.graphYAxis5 = []
        self.graphXAxisLearningError = []
        self.graphYAxisLearningError = []
        self.printRNATable = False
        self.printLearningG=False
        
        # Create the empty lists that we are going to need to store meanings 
        # and signals from agents
        self.meanings = []        
        self.signals = []
            
        # Create the empty lists that we are going to need to store bottlenecks
        # of meanings and signals from agents
        self.bottleneckMeanings = []
        self.bottleneckSignals = []
        
        # Load meanings and signals in the two empty lists
        self.constructSignalsMeanings()
        
        
        # Create an empty dictionary to load codon tables generated by the agents
        # with some statistic variables to control
        self.codonTable={}
        self.notInCodon=[]            # A list to save wich aminoacids are not present in the current codon table 
        self.nOM = 0                  # An integer to count how many aminoacids are present in current codon table
        
        
        # Create some variables to measure the codon tables
        self.compositionality=0
        self.stabilityM=0
        
        # Create some variables to control the writing of the best codon table so far
        self.nExpr= 0
        self.oExpr= 0
        self.nDeltaCode = 1000
        self.oDeltaCode = 1000

            
        #Set up the random population.
        if reloadFlag==False:
            self.population = []
            for i in range(0,params['popSize']):
                self.population.append(Agent(self.params['numInputNeurons'],
                                         self.params['numHiddenNeurons'],
                                            self.params['numOutputNeurons'],
                                            self.params['initWeightSD'],
                                            self.params['learningRate'] ))
        else:
            with open(str(params['randomSeed'])+str(params['popSize'])+'.pkl','rb') as Input:
                    self.population = pickle.load(Input)
                    self.transferNumber = pickle.load(Input)



    # A function to create random meanings and signals in the two empty lists

    def constructSignalsMeanings(self):
        """ We coded the bases in a way that U and C are closer in the space, the same as A and G
            but C and A are far away than the distance between A and G or U and C
        """
        bases3=[0.0,0.3,0.7,1]
        bases12=[0.0,0.3,0.7,1]
        for i,j,k in itertools.product(range(0,4),range(0,4),range(0,4)):
            nextString = [bases12[i],bases12[j],bases3[k]]
            aux = []            
            for c in nextString:
                floatVersion = float(c)
                aux.append(floatVersion)
            self.signals.append(aux)
        for i in range(self.params['maxOutputStringIndex']):
            nextString = Data[i,:]
            self.meanings.append(nextString)


    # A function to create a random codon table (dictionary) if needed
    
    def createRandomCodonTable(self):
        codonTable = {}
        bases=['U','C','A','G']
        for i in range(0,4):
            base3=bases[i]
            for j in range(0,4):
                base2=bases[j]
                for k in range(0,4):
                    base1 = bases[k]
                    codonTable[base1+base2+base3]=CH(aminoAcids)
        return codonTable
    

    # A function to select the bottleneck directly from a codon table (not needed)
    
    def selectBottleneckFromCodonTable(self,cT):
        self.bottleneckMeanings = []
        self.bottleneckSignals = []
        bases3 ={'U':[0.0],'C':[0.3],'A':[0.7],'G':[1.0]}
        bases12 ={'U':[0.0],'C':[0.3],'A':[0.7],'G':[1.0]}
        selectionS = SM(cT.keys(),self.params['bottleNeck'])
        selectionM = []
        for key in selectionS:
            selectionM.append(cT[key])
        for j in range(0,self.params['bottleNeck']):
            self.bottleneckMeanings.append(Data[aminoAcids==selectionM[j]][0])
            self.bottleneckSignals.append(bases12[selectionS[j][0]]+bases12[selectionS[j][1]]+bases3[selectionS[j][2]])
    
    
    # The run function of the simulation class, where the simulation begins
        
    def run(self,reloadFlag=False):
        """After initialisation is complete, we run the model for the amount
        of transfers specified by the maxTransmissions parameter."""
        
        for g in range(0,self.params['maxTransmissions']):
            
            # Reload a population if the flag is True
            if reloadFlag == True:
                g=self.transferNumber
            print ("-------------------------------------------------------")
            print ("Transmission: ", g)
            if self.transferNumber%100==0:
                with open(str(self.params['randomSeed'])+str(self.params['popSize'])+'.pkl','wb') as output:
                    pickle.dump(self.population,output,-1)
                    pickle.dump(self.transferNumber,output,-1)

            # Update the graph's X-axis.
            self.graphXAxis.append(g)
            
            # Update the transfer number
            self.transferNumber=self.transferNumber+1
            
            # Pick a random new learner agent.
            learnerIndex = CH(range(0,self.params['popSize']))
            self.learner = deepcopy(self.population[learnerIndex])
            
            # If the agent is from the first transmission we save his codon table
            
            if(g==0):
                self.codonTable = self.createRandomCodonTable()
                self.exportDNA('firstDNATable.dna')

            # If we want to train the agents with randomly generated 
            # codon tables 
            """if self.learner.firstTimeLearner:
                self.selectBottleneckFromCodonTable(self.randomCodonTable)
                self.learn(self.learner,self.signals,self.meanings)
                self.learner.firstTimeLearner = False
            """
            
            # Re-instert the learner on the population
            self.population[learnerIndex] = deepcopy(self.learner)
            
            # Promote the learner into a speaker
            self.speaker = deepcopy(self.learner)
            
            # Get the codon table of the speaker and export it into a .dna file
            self.codonTable,self.nOM=self.getDNATable(self.speaker)
            self.exportDNA("TransmissionTablesDL\\speaker"+str(self.transferNumber)+'.dna',self.speaker.noOfLE)
            
            # Get the speaker to produce a set of meaning-signal pairs using the
            # obverter procedure.            
            self.speak(self.speaker, self.signals, self.meanings)
            
            # Export the bottleneck into a .bott file
            self.exportBottleneck("TransmissionTablesDL\\"+str(self.transferNumber)+'.bott')
            
            # Pick a new learner agent takig care of not picking the same
            learnerIndex = CH(list(set(range(0,self.params['popSize']))-set([learnerIndex])))            
            self.learner = deepcopy(self.population[learnerIndex])          
            
            # Get the codon table pre-learning and prepare graph stuff of the learning process
            self.graphXAxisLearningError = []
            self.graphYAxisLearningError = []
            self.codonTable,self.nOM=self.getDNATable(self.learner)
            self.exportDNA("TransmissionTablesDL\\pre"+str(self.transferNumber)+'.dna',self.learner.noOfLE)
            
            # Train the agent with the bottleneck generated by the speaker 
            self.learn(self.learner)
            self.learner.firstTimeLearner = False
            self.learner.noOfLE += 1
            
            #Re-instert the learner on the population
            self.population[learnerIndex] = deepcopy(self.learner)
            
            # Get the codon table of the learner agent and print it if needed
            self.codonTable,self.nOM=self.getDNATable(self.learner)
            self.notInCodon = list(set(aminoAcids)-set(self.codonTable.values()))
            self.exportDNA("TransmissionTablesDL\\post"+str(self.transferNumber)+'.dna',self.learner.noOfLE)
            if (self.printRNATable==True):            
                self.printDNA()
            
            #Prepare name for multiple runs with different parameters (if needed)
            #name=str(self.params['randomSeed'])+str(self.params['numHiddenNeurons'])+str(self.params['learningRate'])+str(self.params['bottleNeck'])+str(self.params['numberOfEpochs'])+str(self.params['maxGenerations'])
            
            # Calculate the metrics used for evaluating the codon tables of the speaker and the learner
            self.production(self.speaker, self.learner, self.signals, self.meanings)
            
            # Check if the codon table is the best of the run and save it
            if self.nExpr>self.oExpr:
                self.oDeltaCode = self.nDeltaCode
                self.oExpr = self.nExpr
                self.exportDNA("TransmissionTablesDL\\best.dna",self.learner.noOfLE)
                f = open("TransmissionTablesDL\\bestValues.txt",'w')
                f.write(str(self.oDeltaCode)+" , "+str(self.oExpr))
                f.close()
            else:
                if self.nExpr==self.oExpr:
                    if self.nDeltaCode<self.oDeltaCode:
                        self.oDeltaCode = self.nDeltaCode
                        self.oExpr = self.nExpr
                        self.exportDNA("TransmissionTablesDL\\best.dna",self.learner.noOfLE)
                        f = open("TransmissionTablesDL\\bestValues.txt",'w')
                        f.write(str(self.oDeltaCode)+" , "+str(self.oExpr))
                        f.close()
                        
            # Delete speaker and learner
            del self.speaker
            del self.learner
            
            
            # Import expressivity, delta code, transimissions, compositionality and differences between 
            # tables and between all population
            
            #dOL = self.averageDistance(self.population)
            #self.graphYAxis5.append(dOL)            
            #print("Average distance of full codonTables: "+str(dOL))
            #np.savetxt("Expresivity.csv",self.graphYAxis,delimiter = ',')
            #np.savetxt("deltaCode.csv",self.graphYAxis4,delimiter = ',')
            #np.savetxt("Transmissions.csv",self.graphXAxis,delimiter=',')
            #np.savetxt("Difference.csv",self.graphYAxis2,delimiter=',')
            #np.savetxt("Compositionality.csv",self.graphYAxis3,delimiter=',')
            #np.savetxt("DifferenceALL.csv",self.graphYAxis5,delimiter=',')
                        
        # Create the graphs.
        #self.doGraph()
        #self.doGraph2()
        #self.doGraph3()
        #self.doGraph4()
        
        # Return statistics of the whole run
        return self.nOM,self.compositionality,self.stabilityM
        
    # The learning function
    def learn(self, learner):
        for i in range(0,self.params['numberOfEpochs']):
            selection = SM(range(0, self.params['bottleNeck']),self.params['bottleNeck'])
            errorz = 0
            error = 0
            for j in range(0,self.params['bottleNeck']):
                    meaning = self.bottleneckMeanings[selection[j]]
                    signal = self.bottleneckSignals[selection[j]]
                    learnerUnderstanding, hiddenLevels = learner.calcNetOutput(
                        signal, True)
                    errorz += np.sum(np.abs(learner.trainingEpisode(meaning,learnerUnderstanding,
                                    hiddenLevels, signal)))
                    error += distance.euclidean(meaning,learnerUnderstanding)
            error = error/self.params['bottleNeck']        
            self.graphYAxisLearningError.append(error)
            self.graphXAxisLearningError.append(i)
        if(self.printLearningG==True):
            self.doGraphLE()
            
    def production(self, speaker, learner, signals, meanings):
        ##Collect the data for the output.
        meaningCoverage = self.expressivity()
        self.nExpr = meaningCoverage
        print ("Expressivity: ", meaningCoverage)
        self.graphYAxis.append(meaningCoverage)
        self.stabilityM = self.stability(speaker, learner)
        print ("Stability: ", self.stabilityM)
        langDiffForGraph = 64 - self.stabilityM
        self.graphYAxis2.append(langDiffForGraph)
        """correlationMeasure = self.correlation(learner)
        print ("Correlation: ", correlationMeasure)"""
        self.compositionality = self.compositionalityCalculator(learner)
        self.graphYAxis3.append(self.compositionality)
        print ("Compositionality: ", self.compositionality)
        optimality =self.optimality2(self.codonTable)
        self.nDeltaCode = optimality        
        self.graphYAxis4.append(optimality)
        print("Optimality: "+str(optimality))
            
            

    def expressivity(self):
        return self.nOM

    def stability(self, speaker, learner):
        codonTableL, nOML = self.getDNATable(learner)
        codonTableS, nOMS = self.getDNATable(speaker)
        count = self.compareTables(codonTableL,codonTableS)
        return count

    def compareTables(self,codonTableL,codonTableS):
        count =0
        for key in codonTableL:
            if(codonTableL[key]==codonTableS[key]):
                count+=1
        return count

    def correlation(self, learner):
        mm = float(0)
        ms = float(0)
        n = 0
        correlatedMeanings = []
        for i in range(self.params['maxBitStringIndex']):
            sigs = self.bitStrings[i].produce(self.bitStrings, learner)
            correlatedMeanings.append(sigs)

        for i in range(self.params['maxBitStringIndex']):
            j = 0
            while j < i:
                j += 1
                correlatedIndex = correlatedMeanings[j]
                mm += self.bitStrings[i].ham(self.bitStrings[j].floatRep)
                ms += self.bitStrings[i].ham(
                    self.bitStrings[correlatedIndex].floatRep)
                n += 1

        ms /= n
        mm /= n

        ssm = float(0)
        ss2 = float(0)
        sm2 = float(0)

        for i in range(self.params['maxBitStringIndex']):
            j = 0
            while j < i:
                j += 1
                toCompare = self.bitStrings[j].floatRep
                correlatedIndex2 = correlatedMeanings[j]
                m = float(self.bitStrings[i].ham(toCompare))
                s = float(self.bitStrings[i].ham(
                    self.bitStrings[correlatedIndex2].floatRep))
                ssm += (s - ms) * (m - mm)
                ss2 += (s - ms) * (s - ms)
                sm2 += (m - mm) * (m - mm)
                
        return  ssm / math.sqrt(ss2 * sm2)
    
    def compositionalityCalculator(self, learner):
        allMeanings = []
        allSignals = []

        for i in range(0, self.params['maxOutputStringIndex']):
            allMeanings.append(self.meanings[i])
            meaning = self.meanings[i]
            best = 0
            #Pick the best signal for the choosen meaning.
            for s in range(len(self.signals)):
                currentSignal = self.signals[s]
                inputToNet = currentSignal
                outputFromNet = learner.calcNetOutput(inputToNet, False)
                similarity = self.similarity(outputFromNet,meaning)
                if similarity > best:
                    best = similarity
                    closestSignal = currentSignal
            if best ==0:
                closestSignal = currentSignal
            allSignals.append(closestSignal)

        compositionalityList = []
        for bit in range(0, self.params['lengthOfInputStrings']):
            scores = []
            bitsOfSignal = []
            for signal in allSignals:
                bitsOfSignal.append(signal[bit])
            for meaningBit in range(0, self.params['lengthOfOutputStrings']):
                bitsOfMeaning = []
                for meaning in allMeanings:
                    bitsOfMeaning.append(meaning[meaningBit])
                correlation = stats.pearsonr(bitsOfSignal, bitsOfMeaning)
                scores.append(correlation)
            best = max(scores)
            compositionalityList.append(best)
        compositionality = sum(compositionalityList) / len(compositionalityList)
        return compositionality


    def speak(self, speaker, signals, meanings):
        """Get the speaker to produce meaning-signal pairs as outputs,
        using the obverter procedure."""
        del self.bottleneckMeanings[:]
        del self.bottleneckSignals[:]
        
        selection = SM(range(20),self.params['bottleNeck'])
        for i in range(self.params['bottleNeck']):
            currentMeaning = self.meanings[selection[i]]
            self.bottleneckMeanings.append(currentMeaning)

            best = 0
            for s in range(len(self.signals)):
                currentSignal = deepcopy(self.signals[s])
                outputFromNet = speaker.calcNetOutput(currentSignal,False)
                similarity = self.similarity(currentMeaning, outputFromNet)
                if similarity > best:
                    best = similarity
                    closestSignal = currentSignal
            if best == 0:
                closestSignal = currentSignal
            self.bottleneckSignals.append(closestSignal)
        for i in range(self.params['bottleNeck']):
            if np.random.rand()>0.5:
                self.bottleneckSignals[i]=self.changeSignal(self.bottleneckSignals[i])
    def changeSignal(self,s):
        if s[2]==0.0:
            s[2]=0.3
            return s
        if s[2]==0.3:
            s[2]=0.0
            return s
        if s[2]==1.0:
            s[2]=0.7
            return s
        if s[2]==0.7:
            s[2]=1.0
            return s
        return s

    def similarity(self, m, o):
        prob = 1.0
        for i in range(self.params['lengthOfOutputStrings']):
            prob *=(1-abs(m[i]-o[i])) 
        return prob
        
    def getDNATable(self,speaker):
        bases3 ={'0.0':'U','0.3':'C','0.7':'A','1.0':'G'}
        bases12 ={'0.0':'U','0.3':'C','0.7':'A','1.0':'G'}        
        codonTable = {}
        numberOfMeanings=0        
        for i in range(0,self.params['maxInputStringIndex']):
            currentSignal = deepcopy(self.signals[i])
            best = 0
            for s in range(len(self.meanings)):
                currentMeaning = self.meanings[s]
                outputFromNet = speaker.calcNetOutput(currentSignal,False)
                similarity = self.similarity(currentMeaning, outputFromNet)
                if similarity > best:
                    best = similarity
                    closestMeaning = s
            if best == 0:
                closestMeaning = s
            codon = ''
            codon +=bases12[str(self.signals[i][0])]
            codon +=bases12[str(self.signals[i][1])]
            codon +=bases3[str(self.signals[i][2])]
            if aminoAcids[closestMeaning] not in codonTable.values():
            #if closestMeaning not in codonTable:
                #codonTable.append(closestMeaning)
                numberOfMeanings+=1
            codonTable[codon]=aminoAcids[closestMeaning]
        return codonTable,numberOfMeanings
            
    def exportBottleneck(self,filename):
        f = open(filename,'w')
        bases3 ={'0.0':'U','0.3':'C','0.7':'A','1.0':'G'}
        bases12 ={'0.0':'U','0.3':'C','0.7':'A','1.0':'G'}        
        m = self.bottleneckMeanings
        s = self.bottleneckSignals
        for meaning,signal in zip(m,s):
            f.write(aminoAcids[np.where(np.all(Data==meaning,axis=1))[0][0]]+'\n')
            codon = ''
            codon +=bases12[str(signal[0])]
            codon +=bases12[str(signal[1])]
            codon +=bases3[str(signal[2])]
            f.write(codon+'\n')

    def doGraph(self):
        #Do graph
        font = {'family' : 'serif',
        'color'  : 'black',
        'weight' : 'normal',
        'size'   : 16,
        }
        
        xAxis = range(len(self.graphXAxis ))
        yAxis = self.graphYAxis
        yAxis2 = self.graphYAxis2
        
        figure()
        plt.plot(xAxis, yAxis, "k", color='b', linestyle = 'solid')
        plt.plot(xAxis, yAxis2, "k", color='r', linestyle = 'dashed' )
        plt.title('The Meaning Coverage and Difference of the Language', fontdict=font)
        plt.xlabel('Generations', fontdict=font)
        show()
    
    def doGraph2(self):
        #Do graph
        font = {'family' : 'serif',
        'color'  : 'black',
        'weight' : 'normal',
        'size'   : 16,
        }
        
        xAxis = range(len(self.graphXAxis))
        yAxis = self.graphYAxis3
        
        figure()
        plt.plot(xAxis, yAxis, "k", color='g', linestyle = 'solid')
        plt.title('Compositionality', fontdict=font)
        plt.xlabel('Generations', fontdict=font)
        show()

    def doGraph3(self):
        #Do graph
        font = {'family' : 'serif',
        'color'  : 'black',
        'weight' : 'normal',
        'size'   : 16,
        }
        
        xAxis = range(len(self.graphXAxis))
        yAxis = self.graphYAxis4
        
        figure()
        plt.plot(xAxis, yAxis, "k", color='g', linestyle = 'solid')
        plt.title('Optimality', fontdict=font)
        plt.xlabel('Generations', fontdict=font)
        show()
    
    def doGraph3(self):
        #Do graph
        font = {'family' : 'serif',
        'color'  : 'black',
        'weight' : 'normal',
        'size'   : 16,
        }
        
        xAxis = range(len(self.graphXAxis))
        yAxis = self.graphYAxis5
        
        figure()
        plt.plot(xAxis, yAxis, "k", color='g', linestyle = 'solid')
        plt.title('Distance between codes over the population', fontdict=font)
        plt.xlabel('Generations', fontdict=font)
        show()
        
    def doGraphLE(self):
        #Do graph
        font = {'family' : 'serif',
        'color'  : 'black',
        'weight' : 'normal',
        'size'   : 16,
        }
        
        xAxis = range(len(self.graphXAxisLearningError))
        yAxis = self.graphYAxisLearningError
        
        figure()
        plt.plot(xAxis, yAxis, "k", color='g', linestyle = 'solid')
        plt.title('---', fontdict=font)
        plt.xlabel('Epocs', fontdict=font)
        show()    
    
    def exportDNA(self,filename,nLE=0):
        minimal = "B3"
        maximal = "B2"
        f = open(filename,'w')
        bases=['U','C','A','G']
        if minimal == "B3":
            for i in range(0,4):
                base3=bases[i]
                if maximal == "B2":
                    for j in range(0,4):
                        base2=bases[j]
                        for k in range(0,4):
                            base1 = bases[k]
                            f.write(base1+base2+base3+'\n')
                            f.write(self.codonTable[base1+base2+base3]+'\n')
                            order="1"
                else:
                    for j in range(0,4):
                        base1=bases[j]
                        for k in range(0,4):
                            base2 = bases[k]
                            f.write(base3+base2+base1+'\n')
                            f.write(self.codonTable[base3+base2+base1]+'\n')
                            order="2"
        if minimal == "B2":
            for i in range(0,4):
                base2=bases[i]
                if maximal == "B3":
                    for j in range(0,4):
                        base3=bases[j]
                        for k in range(0,4):
                            base1 = bases[k]
                            f.write(base2+base1+base3+'\n')
                            f.write(self.codonTable[base2+base1+base3]+'\n')
                            order="3"
                else:
                    for j in range(0,4):
                        base1=bases[j]
                        for k in range(0,4):
                            base3 = bases[k]
                            f.write(base2+base3+base1+'\n')
                            f.write(self.codonTable[base2+base3+base1]+'\n')
                            order = "4"
        if minimal == "B1":
            for i in range(0,4):
                base1=bases[i]
                if maximal == "B3":
                    for j in range(0,4):
                        base3=bases[j]
                        for k in range(0,4):
                            base2 = bases[k]
                            f.write(base1+base2+base3+'\n')
                            f.write(self.codonTable[base1+base2+base3]+'\n')
                            order = "5"
                else:
                    for j in range(0,4):
                        base2=bases[j]
                        for k in range(0,4):
                            base3 = bases[k]
                            f.write(base1+base3+base2+'\n')
                            f.write(self.codonTable[base1+base3+base2]+'\n')
                            order = "6"
        f.write(str(self.nOM)+'\n')
        for i in range(0,len(self.notInCodon)):
            f.write(self.notInCodon[i]+'\n')
        f.write(order+'\n')
        f.write(str(nLE)+'\n')
        """for i in range(0,4):
            base3=bases[i]
            for j in range(0,4):
                base2=bases[j]
                for k in range(0,4):
                    base1 = bases[k]
                    if self.codonTable[base3+base1+base2] in class1AA:
                        f.write("I\n")
                    else:
                        f.write("II\n")"""
        f.close()

    def hamdist(self,str1, str2):
        diffs = 0
        for ch1, ch2 in zip(str1, str2):
            if ch1 != ch2:
                diffs += 1
        return diffs    
    
    def optimality2(self,codontable):
        Sum = 0.0        
        for key in codontable.keys():
            SumInd = 0.0
            for key2 in codontable.keys():
                if self.hamdist(key,key2) == 1:
                    pD = polarDisd[aminoAcids==codontable[key],aminoAcids==codontable[key2]][0]
                    SumInd=SumInd+pD*pD
            SumInd = float(SumInd/9)
            Sum+=float(SumInd)
        return float(Sum/64)

    def minimalChange(self,codontable):
        SumB1 = 0.0        
        SumB2 = 0.0
        SumB3 = 0.0        
        for key in codontable.keys():
            SumIndB1 = 0.0
            SumIndB2 = 0.0
            SumIndB3 = 0.0
            for key2 in codontable.keys():
                if self.hamdist(key,key2) == 1:
                    pD = polarDisd[aminoAcids==codontable[key],aminoAcids==codontable[key2]][0]
                    if not key[0]==key2[0]:
                        SumIndB1=SumIndB1+pD*pD
                    if not key[1]==key2[1]:
                        SumIndB2=SumIndB2+pD*pD
                    if not key[2]==key2[2]:
                        SumIndB3=SumIndB3+pD*pD
            SumIndB1 = float(SumIndB1/3)
            SumIndB2 = float(SumIndB2/3)
            SumIndB3 = float(SumIndB3/3)
            SumB1+=float(SumIndB1)
            SumB2+=float(SumIndB2)
            SumB3+=float(SumIndB3)
        if np.min([SumB1,SumB2,SumB3])==SumB1:
            return "B1"
        else:
            if np.min([SumB2,SumB3])==SumB2:
                return "B2"
            else:
                return "B3"

    def maxChange(self,codontable):
        SumB1 = 0.0        
        SumB2 = 0.0
        SumB3 = 0.0        
        for key in codontable.keys():
            SumIndB1 = 0.0
            SumIndB2 = 0.0
            SumIndB3 = 0.0
            for key2 in codontable.keys():
                if self.hamdist(key,key2) == 1:
                    pD = polarDisd[aminoAcids==codontable[key],aminoAcids==codontable[key2]][0]
                    if not key[0]==key2[0]:
                        SumIndB1=SumIndB1+pD*pD
                    if not key[1]==key2[1]:
                        SumIndB2=SumIndB2+pD*pD
                    if not key[2]==key2[2]:
                        SumIndB3=SumIndB3+pD*pD
            SumIndB1 = float(SumIndB1/3)
            SumIndB2 = float(SumIndB2/3)
            SumIndB3 = float(SumIndB3/3)
            SumB1+=float(SumIndB1)
            SumB2+=float(SumIndB2)
            SumB3+=float(SumIndB3)
        if np.max([SumB1,SumB2,SumB3])==SumB1:
            return "B1"
        else:
            if np.max([SumB2,SumB3])==SumB2:
                return "B2"
            else:
                return "B3"
    
    def optimality(self,codontable):
        Sum = 0
        usedKeys = []
        for key in codontable.keys(): 
            for key2 in codontable.keys():
                if key2 not in usedKeys:           
                    if self.hamdist(key,key2) == 1:
                        if codontable[key]==codontable[key2]:
                            Sum+=1*SimilarityMatrix[aminoAcids==codontable[key],aminoAcids==codontable[key2]][0]
            usedKeys.append(key)
        return Sum
    """    
    def exportHydrophobicCodonFreq(self,filename):
        f = open(filename,'w')
        countB1U=0
        countB1C=0
        countB1G=0
        countB1A=0
        countB2U=0
        countB2C=0
        countB2G=0
        countB2A=0
        countB3U=0
        countB3C=0
        countB3G=0
        countB3A=0
        for key in self.codonTable:
            if(key[0]=='U'):
                if self.codonTable[key] in hydrophobicAA:
                    countB1U+=1
            if(key[0]=='G'):
                if self.codonTable[key] in hydrophobicAA:
                    countB1G+=1
            if(key[0]=='A'):
                if self.codonTable[key] in hydrophobicAA:
                    countB1A+=1
            if(key[0]=='C'):
                if self.codonTable[key] in hydrophobicAA:
                    countB1C+=1
            if(key[1]=='U'):
                if self.codonTable[key] in hydrophobicAA:
                    countB2U+=1
            if(key[1]=='G'):
                if self.codonTable[key] in hydrophobicAA:
                    countB2G+=1
            if(key[1]=='A'):
                if self.codonTable[key] in hydrophobicAA:
                    countB2A+=1
            if(key[1]=='C'):
                if self.codonTable[key] in hydrophobicAA:
                    countB2C+=1
            if(key[2]=='U'):
                if self.codonTable[key] in hydrophobicAA:
                    countB3U+=1
            if(key[2]=='G'):
                if self.codonTable[key] in hydrophobicAA:
                    countB3G+=1
            if(key[2]=='A'):
                if self.codonTable[key] in hydrophobicAA:
                    countB3A+=1
            if(key[2]=='C'):
                if self.codonTable[key] in hydrophobicAA:
                    countB3C+=1
        sumB1=countB1U+countB1C+countB1G+countB1A
        sumB2=countB2U+countB2C+countB2G+countB2A
        sumB3=countB3U+countB3C+countB3G+countB3A
        if sumB1==0:
            for i in range(0,4):
                f.write("0\n")
        else:
            f.write(str(countB1U/sumB1)+'\n')
            f.write(str(countB1C/sumB1)+'\n')
            f.write(str(countB1G/sumB1)+'\n')
            f.write(str(countB1A/sumB1)+'\n')
        if sumB2==0:
            for i in range(0,4):
                f.write("0\n")
        else:
            f.write(str(countB2U/sumB2)+'\n')
            f.write(str(countB2C/sumB2)+'\n')
            f.write(str(countB2G/sumB2)+'\n')
            f.write(str(countB2A/sumB2)+'\n')
        if sumB3==0:
            for i in range(0,4):
                f.write("0\n")
        else:
            f.write(str(countB3U/sumB3)+'\n')
            f.write(str(countB3C/sumB3)+'\n')
            f.write(str(countB3G/sumB3)+'\n')
            f.write(str(countB3A/sumB3)+'\n')
        countB1U=0
        countB1C=0
        countB1G=0
        countB1A=0
        countB2U=0
        countB2C=0
        countB2G=0
        countB2A=0
        countB3U=0
        countB3C=0
        countB3G=0
        countB3A=0
        for key in self.codonTable:
            if(key[0]=='U'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB1U+=1
            if(key[0]=='G'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB1G+=1
            if(key[0]=='A'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB1A+=1
            if(key[0]=='C'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB1C+=1
            if(key[1]=='U'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB2U+=1
            if(key[1]=='G'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB2G+=1
            if(key[1]=='A'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB2A+=1
            if(key[1]=='C'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB2C+=1
            if(key[2]=='U'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB3U+=1
            if(key[2]=='G'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB3G+=1
            if(key[2]=='A'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB3A+=1
            if(key[2]=='C'):
                if self.codonTable[key] not in hydrophobicAA:
                    countB3C+=1
        sumB1=countB1U+countB1C+countB1G+countB1A
        sumB2=countB2U+countB2C+countB2G+countB2A
        sumB3=countB3U+countB3C+countB3G+countB3A        
        if sumB1==0:
            for i in range(0,4):
                f.write("0\n")
        else:
            f.write(str(countB1U/sumB1)+'\n')
            f.write(str(countB1C/sumB1)+'\n')
            f.write(str(countB1G/sumB1)+'\n')
            f.write(str(countB1A/sumB1)+'\n')
        if sumB2==0:
            for i in range(0,4):
                f.write("0\n")
        else:
            f.write(str(countB2U/sumB2)+'\n')
            f.write(str(countB2C/sumB2)+'\n')
            f.write(str(countB2G/sumB2)+'\n')
            f.write(str(countB2A/sumB2)+'\n')
        if sumB3==0:
            for i in range(0,4):
                f.write("0\n")
        else:
            f.write(str(countB3U/sumB3)+'\n')
            f.write(str(countB3C/sumB3)+'\n')
            f.write(str(countB3G/sumB3)+'\n')
            f.write(str(countB3A/sumB3)+'\n')
        countHp = 0       
        for key in self.codonTable:
            if self.codonTable[key] in hydrophobicAA:
                countHp+=1
        f.write(str(countHp)+'\n')
        f.write(str(self.nOM)+'\n')
        f.write(str(self.transferNumber)+'\n')
        f.write(str(self.stabilityM/64*100)+'\n')        
        f.close()
        
    def exportClassCodonFreq(self,filename):
        f = open(filename,'w')
        bases=['U','C','A','G']
        for i in range(0,4):
            base3=bases[i]
            for j in range(0,4):
                base2=bases[j]
                for k in range(0,4):
                    base1 = bases[k]
                    f.write(base3+base1+base2+'\n')
                    f.write(self.codonTable[base3+base1+base2]+'\n')
        f.write(str(self.nOM)+'\n')
        for i in range(0,len(self.notInCodon)):
            f.write(self.notInCodon[i]+'\n')
        f.close()
    """        
    def printDNA(self):
        bases=['U','C','A','G']
        print('\t',end='')
        for i in range(0,4):
            print(' ',end='')
            print(bases[i],end='')
            print('\t',end='')
        print('')
        print('')    
        for i in range(0,4):
            base3=bases[i]
            for j in range(0,4):
                base2=bases[j]
                if j==2:
                    print(base3+'\t',end='')
                else:
                    print('\t',end='')
                for k in range(0,4):
                    base1 = bases[k]
                    print(base1+base2+base3,end='')
                    print(':',end='')
                    print(self.codonTable[base1+base2+base3],end='')
                    print('\t',end='')
                print(' '+base2)
            print('')
            print('')
        print("Not in Codon Table AminoAcids")
        for i in range(0,len(self.notInCodon)):
            print(self.notInCodon[i]+" ",end='')
        print("")
    def averageDistance(self,population):
        totalDifference = 0
        Tcount = 0
        codonTables = []
        for i in range(0,len(population)):
            codonTables.append(self.getDNATable(population[i])[0])
        for i in range(0,len(codonTables)):
            count = 0
            differenceI = 0
            for j in range(0,len(codonTables)):
                if not j==i:
                    differenceI += 64-self.compareTables(codonTables[i],codonTables[j])
                    count += 1
            totalDifference += differenceI/count
            Tcount+=1
        return totalDifference/Tcount
            
                    
